import {
  Comment,
  Fragment,
  computed,
  createBaseVNode,
  createCommentVNode,
  createElementBlock,
  defineComponent,
  guardReactiveProps,
  inject,
  markRaw,
  mergeProps,
  normalizeProps,
  onBeforeUnmount,
  onMounted,
  openBlock,
  provide,
  ref,
  renderSlot,
  toRef,
  watch
} from "./chunk-WRYKAXUK.js";

// node_modules/vue3-google-map/dist/index.mjs
(function() {
  "use strict";
  try {
    if (typeof document < "u") {
      var a = document.createElement("style");
      a.appendChild(document.createTextNode(".mapdiv[data-v-c63ff230]{width:100%;height:100%}.advanced-marker-wrapper{display:none}.mapdiv .advanced-marker-wrapper{display:inline-block}.custom-control-wrapper[data-v-ab9120cd]{display:none}.mapdiv .custom-control-wrapper[data-v-ab9120cd]{display:inline-block}.info-window-wrapper[data-v-135889a7]{display:none}.mapdiv .info-window-wrapper[data-v-135889a7]{display:inline-block}.custom-marker-wrapper[data-v-2d2d343a]{display:none}.mapdiv .custom-marker-wrapper[data-v-2d2d343a]{display:inline-block}")), document.head.appendChild(a);
    }
  } catch (d) {
    console.error("vite-plugin-css-injected-by-js", d);
  }
})();
var nt = Object.defineProperty;
var st = (r2, e, t) => e in r2 ? nt(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var pe = (r2, e, t) => (st(r2, typeof e != "symbol" ? e + "" : e, t), t);
var B = Symbol("map");
var D = Symbol("api");
var Ee = Symbol("marker");
var we = Symbol("markerCluster");
var le = Symbol("CustomMarker");
var Ke = Symbol("mapTilesLoaded");
var W = [
  "click",
  "dblclick",
  "drag",
  "dragend",
  "dragstart",
  "mousedown",
  "mousemove",
  "mouseout",
  "mouseover",
  "mouseup",
  "rightclick"
];
function lt(r2, e) {
  r2.src = e;
}
var ut = (r2) => {
  var e, t, n, s = "The Google Maps JavaScript API", o = "google", i = "importLibrary", l = "__ib__", a = document, c = window, d = c[o] || (c[o] = {}), u = d.maps || (d.maps = {}), f = /* @__PURE__ */ new Set(), m = new URLSearchParams(), h = () => e || (e = new Promise(async (p, g) => {
    var v;
    await (t = a.createElement("script")), m.set("libraries", [...f] + "");
    for (n in r2)
      m.set(n.replace(/[A-Z]/g, (_) => "_" + _[0].toLowerCase()), r2[n]);
    m.set("callback", o + ".maps." + l), lt(t, "https://maps.googleapis.com/maps/api/js?" + m), u[l] = p, t.onerror = () => e = g(Error(s + " could not load.")), t.nonce = ((v = a.querySelector("script[nonce]")) == null ? void 0 : v.nonce) || "", a.head.append(t);
  }));
  u[i] ? console.warn(s + " only loads once. Ignoring:", r2) : u[i] = (p, ...g) => f.add(p) && h().then(() => u[i](p, ...g));
};
var ct = (r2) => `The setOptions() function should only be called once. The options passed to the additional call (${JSON.stringify(r2)}) will be ignored.`;
var pt = (r2) => `The google.maps.importLibrary() function is already defined, and @googlemaps/js-api-loader will use the existing function instead of overwriting it. The options passed to setOptions (${JSON.stringify(r2)}) will be ignored.`;
var dt = "No options were set before calling importLibrary. Make sure to configure the loader using setOptions().";
var ft = "There already is a script loading the Google Maps JavaScript API, and no google.maps.importLibrary function is defined. @googlemaps/js-api-loader will proceed to bootstrap the API with the specified options, but the existing script might cause problems using the API. Make sure to remove the script loading the API.";
var ke = true ? (r2) => {
  console.warn(`[@googlemaps/js-api-loader] ${r2}`);
} : () => {
};
var ht = true ? (r2) => {
  console.info(`[@googlemaps/js-api-loader] ${r2}`);
} : () => {
};
var me = false;
function mt(r2) {
  if (me) {
    ke(ct(r2));
    return;
  }
  vt(r2), me = true;
}
async function gt(r2) {
  var e, t;
  if (me || ke(dt), !((t = (e = window == null ? void 0 : window.google) == null ? void 0 : e.maps) != null && t.importLibrary))
    throw new Error("google.maps.importLibrary is not installed.");
  return await google.maps.importLibrary(r2);
}
function vt(r2) {
  var t, n;
  const e = !!((n = (t = window.google) == null ? void 0 : t.maps) != null && n.importLibrary);
  e ? ht(pt(r2)) : document.querySelector('script[src*="maps.googleapis.com/maps/api/js"]') && ke(ft), e || ut(r2);
}
function yt(r2) {
  return class extends r2.OverlayView {
    constructor(n) {
      super();
      pe(this, "element");
      pe(this, "opts");
      const { element: s, ...o } = n;
      this.element = s, this.opts = o, this.opts.map && this.setMap(this.opts.map);
    }
    getPosition() {
      return this.opts.position ? this.opts.position instanceof r2.LatLng ? this.opts.position : new r2.LatLng(this.opts.position) : null;
    }
    getVisible() {
      if (!this.element)
        return false;
      const n = this.element;
      return n.style.display !== "none" && n.style.visibility !== "hidden" && (n.style.opacity === "" || Number(n.style.opacity) > 0.01);
    }
    onAdd() {
      if (!this.element)
        return;
      const n = this.getPanes();
      n && n.overlayMouseTarget.appendChild(this.element);
    }
    draw() {
      if (!this.element)
        return;
      const n = this.getProjection(), s = n == null ? void 0 : n.fromLatLngToDivPixel(this.getPosition());
      if (s) {
        this.element.style.position = "absolute";
        let o, i;
        switch (this.opts.anchorPoint) {
          case "TOP_CENTER":
            o = "-50%", i = "-100%";
            break;
          case "BOTTOM_CENTER":
            o = "-50%", i = "0";
            break;
          case "LEFT_CENTER":
            o = "-100%", i = "-50%";
            break;
          case "RIGHT_CENTER":
            o = "0", i = "-50%";
            break;
          case "TOP_LEFT":
            o = "-100%", i = "-100%";
            break;
          case "TOP_RIGHT":
            o = "0", i = "-100%";
            break;
          case "BOTTOM_LEFT":
            o = "-100%", i = "0";
            break;
          case "BOTTOM_RIGHT":
            o = "0", i = "0";
            break;
          default:
            o = "-50%", i = "-50%";
        }
        const l = s.x + (this.opts.offsetX || 0) + "px", a = s.y + (this.opts.offsetY || 0) + "px";
        this.element.style.transform = `translateX(${o}) translateX(${l}) translateY(${i}) translateY(${a})`, this.opts.zIndex && (this.element.style.zIndex = this.opts.zIndex.toString());
      }
    }
    onRemove() {
      this.element && this.element.remove();
    }
    setOptions(n) {
      const { element: s, ...o } = n;
      this.element = s, this.opts = o, this.draw();
    }
  };
}
var Pe = false;
var be = [
  "bounds_changed",
  "center_changed",
  "click",
  "contextmenu",
  "dblclick",
  "drag",
  "dragend",
  "dragstart",
  "heading_changed",
  "idle",
  "isfractionalzoomenabled_changed",
  "mapcapabilities_changed",
  "maptypeid_changed",
  "mousemove",
  "mouseout",
  "mouseover",
  "projection_changed",
  "renderingtype_changed",
  "rightclick",
  "tilesloaded",
  "tilt_changed",
  "zoom_changed"
];
var _t = defineComponent({
  props: {
    apiPromise: {
      type: Promise
    },
    apiKey: {
      type: String,
      default: ""
    },
    version: {
      type: String,
      default: "weekly"
    },
    libraries: {
      type: Array,
      default: () => ["places", "marker"]
    },
    region: {
      type: String,
      required: false
    },
    language: {
      type: String,
      required: false
    },
    backgroundColor: {
      type: String,
      required: false
    },
    center: {
      type: Object,
      default: () => ({ lat: 0, lng: 0 })
    },
    clickableIcons: {
      type: Boolean,
      required: false,
      default: void 0
    },
    colorScheme: {
      type: String,
      required: false
    },
    controlSize: {
      type: Number,
      required: false
    },
    disableDefaultUi: {
      type: Boolean,
      required: false,
      default: void 0
    },
    disableDoubleClickZoom: {
      type: Boolean,
      required: false,
      default: void 0
    },
    draggable: {
      type: Boolean,
      required: false,
      default: void 0
    },
    draggableCursor: {
      type: String,
      required: false
    },
    draggingCursor: {
      type: String,
      required: false
    },
    fullscreenControl: {
      type: Boolean,
      required: false,
      default: void 0
    },
    fullscreenControlPosition: {
      type: String,
      required: false
    },
    gestureHandling: {
      type: String,
      required: false
    },
    heading: {
      type: Number,
      required: false
    },
    isFractionalZoomEnabled: {
      type: Boolean,
      required: false,
      default: void 0
    },
    keyboardShortcuts: {
      type: Boolean,
      required: false,
      default: void 0
    },
    mapTypeControl: {
      type: Boolean,
      required: false,
      default: void 0
    },
    mapTypeControlOptions: {
      type: Object,
      required: false
    },
    mapTypeId: {
      type: [Number, String],
      required: false
    },
    mapId: {
      type: String,
      required: false
    },
    maxZoom: {
      type: Number,
      required: false
    },
    minZoom: {
      type: Number,
      required: false
    },
    noClear: {
      type: Boolean,
      required: false,
      default: void 0
    },
    panControl: {
      type: Boolean,
      required: false,
      default: void 0
    },
    panControlPosition: {
      type: String,
      required: false
    },
    restriction: {
      type: Object,
      required: false
    },
    rotateControl: {
      type: Boolean,
      required: false,
      default: void 0
    },
    rotateControlPosition: {
      type: String,
      required: false
    },
    scaleControl: {
      type: Boolean,
      required: false,
      default: void 0
    },
    scaleControlStyle: {
      type: Number,
      required: false
    },
    scrollwheel: {
      type: Boolean,
      required: false,
      default: void 0
    },
    streetView: {
      type: Object,
      required: false
    },
    streetViewControl: {
      type: Boolean,
      required: false,
      default: void 0
    },
    streetViewControlPosition: {
      type: String,
      required: false
    },
    styles: {
      type: Array,
      required: false
    },
    tilt: {
      type: Number,
      required: false
    },
    zoom: {
      type: Number,
      required: false
    },
    zoomControl: {
      type: Boolean,
      required: false,
      default: void 0
    },
    zoomControlPosition: {
      type: String,
      required: false
    },
    cameraControl: {
      type: Boolean,
      required: false,
      default: void 0
    },
    cameraControlPosition: {
      type: String,
      required: false
    }
  },
  emits: be,
  setup(r2, { emit: e }) {
    const t = ref(), n = ref(false), s = ref(), o = ref(), i = ref(false);
    provide(B, s), provide(D, o), provide(Ke, i);
    const l = () => {
      const u = { ...r2 };
      Object.keys(u).forEach((p) => {
        u[p] === void 0 && delete u[p];
      });
      const m = (p) => {
        var g;
        return p ? { position: (g = o.value) == null ? void 0 : g.ControlPosition[p] } : {};
      }, h = {
        scaleControlOptions: r2.scaleControlStyle ? { style: r2.scaleControlStyle } : {},
        panControlOptions: m(r2.panControlPosition),
        zoomControlOptions: m(r2.zoomControlPosition),
        rotateControlOptions: m(r2.rotateControlPosition),
        streetViewControlOptions: m(r2.streetViewControlPosition),
        fullscreenControlOptions: m(r2.fullscreenControlPosition),
        cameraControlOptions: m(r2.cameraControlPosition),
        disableDefaultUI: r2.disableDefaultUi
      };
      return { ...u, ...h };
    }, a = watch(
      [o, s],
      ([u, f]) => {
        const m = u, h = f;
        m && h && (m.event.addListenerOnce(h, "tilesloaded", () => {
          i.value = true;
        }), setTimeout(a, 0));
      },
      { immediate: true }
    ), c = () => {
      const { apiKey: u, region: f, version: m, language: h, libraries: p } = r2;
      mt({ key: u, region: f, v: m, language: h, libraries: p });
    }, d = (u) => {
      const f = u ? u.maps : google.maps;
      o.value = markRaw(f), s.value = markRaw(new f.Map(t.value, l()));
      const m = yt(o.value);
      o.value[le] = m, be.forEach((p) => {
        var g;
        (g = s.value) == null || g.addListener(p, (v) => e(p, v));
      }), n.value = true;
      const h = Object.keys(r2).filter(
        (p) => !["apiPromise", "apiKey", "version", "libraries", "region", "language", "center", "zoom"].includes(p)
      ).map((p) => toRef(r2, p));
      watch(
        [() => r2.center, () => r2.zoom, ...h],
        ([p, g], [v, _]) => {
          var C, T, K;
          const { center: E, zoom: q, ...P } = l();
          (C = s.value) == null || C.setOptions(P), g !== void 0 && g !== _ && ((T = s.value) == null || T.setZoom(g));
          const b = !v || p.lng !== v.lng || p.lat !== v.lat;
          p && b && ((K = s.value) == null || K.panTo(p));
        }
      );
    };
    return onMounted(() => {
      if (r2.apiPromise && r2.apiPromise instanceof Promise)
        r2.apiPromise.then(d);
      else {
        Pe || (c(), Pe = true);
        const u = r2.libraries && r2.libraries.length > 0 ? r2.libraries : ["maps", "marker"];
        Promise.all(u.map((f) => gt(f))).then(() => d());
      }
    }), onBeforeUnmount(() => {
      var u;
      i.value = false, s.value && ((u = o.value) == null || u.event.clearInstanceListeners(s.value));
    }), { mapRef: t, ready: n, map: s, api: o, mapTilesLoaded: i };
  }
});
var te = (r2, e) => {
  const t = r2.__vccOpts || r2;
  for (const [n, s] of e)
    t[n] = s;
  return t;
};
var Et = {
  ref: "mapRef",
  class: "mapdiv"
};
function wt(r2, e, t, n, s, o) {
  return openBlock(), createElementBlock("div", null, [
    createBaseVNode("div", Et, null, 512),
    renderSlot(r2.$slots, "default", normalizeProps(guardReactiveProps({ ready: r2.ready, map: r2.map, api: r2.api, mapTilesLoaded: r2.mapTilesLoaded })), void 0, true)
  ]);
}
var jr = te(_t, [["render", wt], ["__scopeId", "data-v-c63ff230"]]);
function kt(r2) {
  return r2 && r2.__esModule && Object.prototype.hasOwnProperty.call(r2, "default") ? r2.default : r2;
}
var Ct = function r(e, t) {
  if (e === t)
    return true;
  if (e && t && typeof e == "object" && typeof t == "object") {
    if (e.constructor !== t.constructor)
      return false;
    var n, s, o;
    if (Array.isArray(e)) {
      if (n = e.length, n != t.length)
        return false;
      for (s = n; s-- !== 0; )
        if (!r(e[s], t[s]))
          return false;
      return true;
    }
    if (e.constructor === RegExp)
      return e.source === t.source && e.flags === t.flags;
    if (e.valueOf !== Object.prototype.valueOf)
      return e.valueOf() === t.valueOf();
    if (e.toString !== Object.prototype.toString)
      return e.toString() === t.toString();
    if (o = Object.keys(e), n = o.length, n !== Object.keys(t).length)
      return false;
    for (s = n; s-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(t, o[s]))
        return false;
    for (s = n; s-- !== 0; ) {
      var i = o[s];
      if (!r(e[i], t[i]))
        return false;
    }
    return true;
  }
  return e !== e && t !== t;
};
var Q = kt(Ct);
var Se = ["click", "drag", "dragend", "dragstart", "gmp-click"];
var Ot = defineComponent({
  name: "AdvancedMarker",
  props: {
    options: {
      type: Object,
      required: true
    },
    pinOptions: {
      type: Object,
      required: false
    }
  },
  emits: Se,
  setup(r2, { emit: e, expose: t, slots: n }) {
    const s = ref(), o = computed(() => {
      var m;
      return (m = n.content) == null ? void 0 : m.call(n).some((h) => h.type !== Comment);
    }), i = toRef(r2, "options"), l = toRef(r2, "pinOptions"), a = ref(), c = inject(B, ref()), d = inject(D, ref()), u = inject(we, ref()), f = computed(
      () => !!(u.value && d.value && a.value instanceof google.maps.marker.AdvancedMarkerElement)
    );
    return watch(
      [c, i, l, s],
      async (m, [h, p, g, v]) => {
        var C, T, K;
        const _ = !Q(i.value, p) || !Q(l.value, g), E = s.value !== v, q = _ || E || c.value !== h;
        if (!c.value || !d.value || !q || o.value && !s.value)
          return;
        const { AdvancedMarkerElement: P, PinElement: b } = d.value.marker;
        if (a.value) {
          const { map: ue, content: re, ...ce } = i.value;
          Object.assign(a.value, {
            content: o.value ? s.value : l.value ? new b(l.value).element : re,
            ...ce
          }), f.value && ((C = u.value) == null || C.removeMarker(a.value), (T = u.value) == null || T.addMarker(a.value));
        } else
          o.value ? i.value.content = s.value : l.value && (i.value.content = new b(l.value).element), a.value = markRaw(new P(i.value)), f.value ? (K = u.value) == null || K.addMarker(a.value) : a.value.map = c.value, Se.forEach((ue) => {
            var re;
            (re = a.value) == null || re.addListener(ue, (ce) => e(ue, ce));
          });
      },
      {
        immediate: true,
        flush: "post"
        // Ensure DOM updates happen before this watcher runs
      }
    ), onBeforeUnmount(() => {
      var m, h;
      a.value && ((m = d.value) == null || m.event.clearInstanceListeners(a.value), f.value ? (h = u.value) == null || h.removeMarker(a.value) : a.value.map = null);
    }), provide(Ee, a), t({ marker: a }), { hasCustomSlotContent: o, markerRef: s };
  }
});
var Mt = {
  key: 0,
  class: "advanced-marker-wrapper"
};
function Pt(r2, e, t, n, s, o) {
  return openBlock(), createElementBlock(Fragment, null, [
    r2.hasCustomSlotContent ? (openBlock(), createElementBlock("div", Mt, [
      createBaseVNode("div", mergeProps({ ref: "markerRef" }, r2.$attrs), [
        renderSlot(r2.$slots, "content")
      ], 16)
    ])) : createCommentVNode("", true),
    renderSlot(r2.$slots, "default")
  ], 64);
}
var Nr = te(Ot, [["render", Pt]]);
var Ae = (r2) => r2 === "Marker";
var qe = (r2) => r2 === le;
var H = (r2, e, t, n) => {
  const s = ref(), o = inject(B, ref()), i = inject(D, ref()), l = inject(we, ref()), a = computed(
    () => !!(l.value && i.value && (s.value instanceof i.value.Marker || s.value instanceof i.value[le]))
  );
  return watch(
    [o, t],
    (c, [d, u]) => {
      var m, h, p;
      const f = !Q(t.value, u) || o.value !== d;
      if (!(!o.value || !i.value || !f))
        if (s.value)
          s.value.setOptions(t.value), a.value && ((m = l.value) == null || m.removeMarker(s.value), (h = l.value) == null || h.addMarker(s.value));
        else {
          if (Ae(r2))
            s.value = markRaw(
              new i.value[r2](t.value)
            );
          else if (qe(r2)) {
            const g = t.value;
            g.element && (s.value = markRaw(new i.value[r2](g)));
          } else
            s.value = markRaw(
              new i.value[r2]({
                ...t.value,
                map: o.value
              })
            );
          s.value && (a.value ? (p = l.value) == null || p.addMarker(s.value) : (Ae(r2) || qe(r2)) && s.value.setMap(o.value)), e.forEach((g) => {
            var v;
            (v = s.value) == null || v.addListener(g, (_) => n(g, _));
          });
        }
    },
    {
      immediate: true,
      flush: "post"
    }
  ), onBeforeUnmount(() => {
    var c, d;
    s.value && ((c = i.value) == null || c.event.clearInstanceListeners(s.value), a.value ? (d = l.value) == null || d.removeMarker(s.value) : s.value.setMap(null));
  }), s;
};
var Te = [
  "animation_changed",
  "click",
  "dblclick",
  "rightclick",
  "dragstart",
  "dragend",
  "drag",
  "mouseover",
  "mousedown",
  "mouseout",
  "mouseup",
  "draggable_changed",
  "clickable_changed",
  "contextmenu",
  "cursor_changed",
  "flat_changed",
  "zindex_changed",
  "icon_changed",
  "position_changed",
  "shape_changed",
  "title_changed",
  "visible_changed"
];
var $r = defineComponent({
  name: "Marker",
  props: {
    options: {
      type: Object,
      required: true
    }
  },
  emits: Te,
  setup(r2, { emit: e, expose: t, slots: n }) {
    const s = toRef(r2, "options"), o = H("Marker", Te, s, e);
    return provide(Ee, o), t({ marker: o }), () => {
      var i;
      return (i = n.default) == null ? void 0 : i.call(n);
    };
  }
});
var Br = defineComponent({
  name: "Polyline",
  props: {
    options: {
      type: Object,
      required: true
    }
  },
  emits: W,
  setup(r2, { emit: e }) {
    const t = toRef(r2, "options");
    return { polyline: H("Polyline", W, t, e) };
  },
  render: () => null
});
var Dr = defineComponent({
  name: "Polygon",
  props: {
    options: {
      type: Object,
      required: true
    }
  },
  emits: W,
  setup(r2, { emit: e }) {
    const t = toRef(r2, "options");
    return { polygon: H("Polygon", W, t, e) };
  },
  render: () => null
});
var Le = W.concat(["bounds_changed"]);
var Zr = defineComponent({
  name: "Rectangle",
  props: {
    options: {
      type: Object,
      required: true
    }
  },
  emits: Le,
  setup(r2, { emit: e }) {
    const t = toRef(r2, "options");
    return { rectangle: H("Rectangle", Le, t, e) };
  },
  render: () => null
});
var xe = W.concat(["center_changed", "radius_changed"]);
var Ur = defineComponent({
  name: "Circle",
  props: {
    options: {
      type: Object,
      required: true
    }
  },
  emits: xe,
  setup(r2, { emit: e }) {
    const t = toRef(r2, "options");
    return { circle: H("Circle", xe, t, e) };
  },
  render: () => null
});
var bt = defineComponent({
  props: {
    position: {
      type: String,
      required: true
    },
    index: {
      type: Number,
      default: 1
    }
  },
  emits: ["content:loaded"],
  setup(r2, { emit: e }) {
    const t = ref(null), n = inject(B, ref()), s = inject(D, ref()), o = inject(Ke, ref(false)), i = watch(
      [o, s, t],
      ([c, d, u]) => {
        d && c && u && (l(r2.position), e("content:loaded"), setTimeout(i, 0));
      },
      { immediate: true }
    ), l = (c) => {
      if (n.value && s.value && t.value) {
        const d = s.value.ControlPosition[c];
        t.value.index = r2.index, n.value.controls[d].push(t.value);
      }
    }, a = (c) => {
      if (n.value && s.value) {
        let d = null;
        const u = s.value.ControlPosition[c];
        n.value.controls[u].forEach((f, m) => {
          f === t.value && (d = m);
        }), d !== null && n.value.controls[u].removeAt(d);
      }
    };
    return onBeforeUnmount(() => a(r2.position)), watch(
      () => r2.position,
      (c, d) => {
        a(d), l(c);
      }
    ), watch(
      () => r2.index,
      (c) => {
        t.value && (t.value.index = c);
      }
    ), { controlRef: t };
  }
});
var St = {
  ref: "controlRef",
  class: "custom-control-wrapper"
};
function At(r2, e, t, n, s, o) {
  return openBlock(), createElementBlock("div", St, [
    renderSlot(r2.$slots, "default", {}, void 0, true)
  ], 512);
}
var Gr = te(bt, [["render", At], ["__scopeId", "data-v-ab9120cd"]]);
var Ie = [
  "closeclick",
  "content_changed",
  "domready",
  "position_changed",
  "visible",
  "zindex_changed"
];
var qt = defineComponent({
  inheritAttrs: false,
  props: {
    options: {
      type: Object,
      default: () => ({})
    },
    modelValue: {
      type: Boolean
    }
  },
  emits: [...Ie, "update:modelValue"],
  setup(r2, { slots: e, emit: t, expose: n }) {
    const s = ref(), o = ref(), i = inject(B, ref()), l = inject(D, ref()), a = inject(Ee, ref());
    let c, d = r2.modelValue;
    const u = computed(() => {
      var p;
      return (p = e.default) == null ? void 0 : p.call(e).some((g) => g.type !== Comment);
    }), f = (p) => {
      d = p, t("update:modelValue", p);
    }, m = (p) => {
      s.value && (s.value.open({ map: i.value, anchor: a.value, ...p }), f(true));
    }, h = () => {
      s.value && (s.value.close(), f(false));
    };
    return onMounted(() => {
      watch(
        [i, () => r2.options],
        ([p, g], [v, _]) => {
          var q;
          const E = !Q(g, _) || i.value !== v;
          i.value && l.value && E && (s.value ? (s.value.setOptions({
            ...g,
            content: u.value ? o.value : g.content
          }), a.value || m()) : (s.value = markRaw(
            new l.value.InfoWindow({
              ...g,
              content: u.value ? o.value : g.content
            })
          ), a.value && (c = a.value.addListener("click", () => {
            m();
          })), (!a.value || d) && m(), Ie.forEach((P) => {
            var b;
            (b = s.value) == null || b.addListener(P, (C) => t(P, C));
          }), (q = s.value) == null || q.addListener("closeclick", () => f(false))));
        },
        {
          immediate: true,
          flush: "post"
        }
      ), watch(
        () => r2.modelValue,
        (p) => {
          p !== d && (p ? m() : h());
        }
      );
    }), onBeforeUnmount(() => {
      var p;
      c && c.remove(), s.value && ((p = l.value) == null || p.event.clearInstanceListeners(s.value), h());
    }), n({ infoWindow: s, open: m, close: h }), { infoWindow: s, infoWindowRef: o, hasSlotContent: u, open: m, close: h };
  }
});
var Tt = {
  key: 0,
  class: "info-window-wrapper"
};
function Lt(r2, e, t, n, s, o) {
  return r2.hasSlotContent ? (openBlock(), createElementBlock("div", Tt, [
    createBaseVNode("div", mergeProps({ ref: "infoWindowRef" }, r2.$attrs), [
      renderSlot(r2.$slots, "default", {}, void 0, true)
    ], 16)
  ])) : createCommentVNode("", true);
}
var Vr = te(qt, [["render", Lt], ["__scopeId", "data-v-135889a7"]]);
var xt = Object.getOwnPropertyNames;
var It = Object.getOwnPropertySymbols;
var Rt = Object.prototype.hasOwnProperty;
function Re(r2, e) {
  return function(n, s, o) {
    return r2(n, s, o) && e(n, s, o);
  };
}
function ne(r2) {
  return function(t, n, s) {
    if (!t || !n || typeof t != "object" || typeof n != "object")
      return r2(t, n, s);
    var o = s.cache, i = o.get(t), l = o.get(n);
    if (i && l)
      return i === n && l === t;
    o.set(t, n), o.set(n, t);
    var a = r2(t, n, s);
    return o.delete(t), o.delete(n), a;
  };
}
function je(r2) {
  return xt(r2).concat(It(r2));
}
var jt = Object.hasOwn || function(r2, e) {
  return Rt.call(r2, e);
};
function Z(r2, e) {
  return r2 === e || !r2 && !e && r2 !== r2 && e !== e;
}
var Nt = "__v";
var $t = "__o";
var Bt = "_owner";
var Ne = Object.getOwnPropertyDescriptor;
var $e = Object.keys;
function Dt(r2, e, t) {
  var n = r2.length;
  if (e.length !== n)
    return false;
  for (; n-- > 0; )
    if (!t.equals(r2[n], e[n], n, n, r2, e, t))
      return false;
  return true;
}
function Zt(r2, e) {
  return Z(r2.getTime(), e.getTime());
}
function Ut(r2, e) {
  return r2.name === e.name && r2.message === e.message && r2.cause === e.cause && r2.stack === e.stack;
}
function Gt(r2, e) {
  return r2 === e;
}
function Be(r2, e, t) {
  var n = r2.size;
  if (n !== e.size)
    return false;
  if (!n)
    return true;
  for (var s = new Array(n), o = r2.entries(), i, l, a = 0; (i = o.next()) && !i.done; ) {
    for (var c = e.entries(), d = false, u = 0; (l = c.next()) && !l.done; ) {
      if (s[u]) {
        u++;
        continue;
      }
      var f = i.value, m = l.value;
      if (t.equals(f[0], m[0], a, u, r2, e, t) && t.equals(f[1], m[1], f[0], m[0], r2, e, t)) {
        d = s[u] = true;
        break;
      }
      u++;
    }
    if (!d)
      return false;
    a++;
  }
  return true;
}
var Vt = Z;
function Ft(r2, e, t) {
  var n = $e(r2), s = n.length;
  if ($e(e).length !== s)
    return false;
  for (; s-- > 0; )
    if (!Ye(r2, e, t, n[s]))
      return false;
  return true;
}
function Y(r2, e, t) {
  var n = je(r2), s = n.length;
  if (je(e).length !== s)
    return false;
  for (var o, i, l; s-- > 0; )
    if (o = n[s], !Ye(r2, e, t, o) || (i = Ne(r2, o), l = Ne(e, o), (i || l) && (!i || !l || i.configurable !== l.configurable || i.enumerable !== l.enumerable || i.writable !== l.writable)))
      return false;
  return true;
}
function zt(r2, e) {
  return Z(r2.valueOf(), e.valueOf());
}
function Wt(r2, e) {
  return r2.source === e.source && r2.flags === e.flags;
}
function De(r2, e, t) {
  var n = r2.size;
  if (n !== e.size)
    return false;
  if (!n)
    return true;
  for (var s = new Array(n), o = r2.values(), i, l; (i = o.next()) && !i.done; ) {
    for (var a = e.values(), c = false, d = 0; (l = a.next()) && !l.done; ) {
      if (!s[d] && t.equals(i.value, l.value, i.value, l.value, r2, e, t)) {
        c = s[d] = true;
        break;
      }
      d++;
    }
    if (!c)
      return false;
  }
  return true;
}
function Ht(r2, e) {
  var t = r2.length;
  if (e.length !== t)
    return false;
  for (; t-- > 0; )
    if (r2[t] !== e[t])
      return false;
  return true;
}
function Kt(r2, e) {
  return r2.hostname === e.hostname && r2.pathname === e.pathname && r2.protocol === e.protocol && r2.port === e.port && r2.hash === e.hash && r2.username === e.username && r2.password === e.password;
}
function Ye(r2, e, t, n) {
  return (n === Bt || n === $t || n === Nt) && (r2.$$typeof || e.$$typeof) ? true : jt(e, n) && t.equals(r2[n], e[n], n, n, r2, e, t);
}
var Yt = "[object Arguments]";
var Jt = "[object Boolean]";
var Xt = "[object Date]";
var Qt = "[object Error]";
var er = "[object Map]";
var tr = "[object Number]";
var rr = "[object Object]";
var nr = "[object RegExp]";
var sr = "[object Set]";
var or = "[object String]";
var ar = "[object URL]";
var ir = Array.isArray;
var Ze = typeof ArrayBuffer == "function" && ArrayBuffer.isView ? ArrayBuffer.isView : null;
var Ue = Object.assign;
var lr = Object.prototype.toString.call.bind(Object.prototype.toString);
function ur(r2) {
  var e = r2.areArraysEqual, t = r2.areDatesEqual, n = r2.areErrorsEqual, s = r2.areFunctionsEqual, o = r2.areMapsEqual, i = r2.areNumbersEqual, l = r2.areObjectsEqual, a = r2.arePrimitiveWrappersEqual, c = r2.areRegExpsEqual, d = r2.areSetsEqual, u = r2.areTypedArraysEqual, f = r2.areUrlsEqual;
  return function(h, p, g) {
    if (h === p)
      return true;
    if (h == null || p == null)
      return false;
    var v = typeof h;
    if (v !== typeof p)
      return false;
    if (v !== "object")
      return v === "number" ? i(h, p, g) : v === "function" ? s(h, p, g) : false;
    var _ = h.constructor;
    if (_ !== p.constructor)
      return false;
    if (_ === Object)
      return l(h, p, g);
    if (ir(h))
      return e(h, p, g);
    if (Ze != null && Ze(h))
      return u(h, p, g);
    if (_ === Date)
      return t(h, p, g);
    if (_ === RegExp)
      return c(h, p, g);
    if (_ === Map)
      return o(h, p, g);
    if (_ === Set)
      return d(h, p, g);
    var E = lr(h);
    return E === Xt ? t(h, p, g) : E === nr ? c(h, p, g) : E === er ? o(h, p, g) : E === sr ? d(h, p, g) : E === rr ? typeof h.then != "function" && typeof p.then != "function" && l(h, p, g) : E === ar ? f(h, p, g) : E === Qt ? n(h, p, g) : E === Yt ? l(h, p, g) : E === Jt || E === tr || E === or ? a(h, p, g) : false;
  };
}
function cr(r2) {
  var e = r2.circular, t = r2.createCustomConfig, n = r2.strict, s = {
    areArraysEqual: n ? Y : Dt,
    areDatesEqual: Zt,
    areErrorsEqual: Ut,
    areFunctionsEqual: Gt,
    areMapsEqual: n ? Re(Be, Y) : Be,
    areNumbersEqual: Vt,
    areObjectsEqual: n ? Y : Ft,
    arePrimitiveWrappersEqual: zt,
    areRegExpsEqual: Wt,
    areSetsEqual: n ? Re(De, Y) : De,
    areTypedArraysEqual: n ? Y : Ht,
    areUrlsEqual: Kt
  };
  if (t && (s = Ue({}, s, t(s))), e) {
    var o = ne(s.areArraysEqual), i = ne(s.areMapsEqual), l = ne(s.areObjectsEqual), a = ne(s.areSetsEqual);
    s = Ue({}, s, {
      areArraysEqual: o,
      areMapsEqual: i,
      areObjectsEqual: l,
      areSetsEqual: a
    });
  }
  return s;
}
function pr(r2) {
  return function(e, t, n, s, o, i, l) {
    return r2(e, t, l);
  };
}
function dr(r2) {
  var e = r2.circular, t = r2.comparator, n = r2.createState, s = r2.equals, o = r2.strict;
  if (n)
    return function(a, c) {
      var d = n(), u = d.cache, f = u === void 0 ? e ? /* @__PURE__ */ new WeakMap() : void 0 : u, m = d.meta;
      return t(a, c, {
        cache: f,
        equals: s,
        meta: m,
        strict: o
      });
    };
  if (e)
    return function(a, c) {
      return t(a, c, {
        cache: /* @__PURE__ */ new WeakMap(),
        equals: s,
        meta: void 0,
        strict: o
      });
    };
  var i = {
    cache: void 0,
    equals: s,
    meta: void 0,
    strict: o
  };
  return function(a, c) {
    return t(a, c, i);
  };
}
var ae = j();
j({ strict: true });
j({ circular: true });
j({
  circular: true,
  strict: true
});
j({
  createInternalComparator: function() {
    return Z;
  }
});
j({
  strict: true,
  createInternalComparator: function() {
    return Z;
  }
});
j({
  circular: true,
  createInternalComparator: function() {
    return Z;
  }
});
j({
  circular: true,
  createInternalComparator: function() {
    return Z;
  },
  strict: true
});
function j(r2) {
  r2 === void 0 && (r2 = {});
  var e = r2.circular, t = e === void 0 ? false : e, n = r2.createInternalComparator, s = r2.createState, o = r2.strict, i = o === void 0 ? false : o, l = cr(r2), a = ur(l), c = n ? n(a) : pr(a);
  return dr({ circular: t, comparator: a, createState: s, equals: c, strict: i });
}
var Ge = [
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array
];
var de = 1;
var J = 8;
var Ce = class _Ce {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(e) {
    if (!(e instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    const [t, n] = new Uint8Array(e, 0, 2);
    if (t !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    const s = n >> 4;
    if (s !== de)
      throw new Error(`Got v${s} data when expected v${de}.`);
    const o = Ge[n & 15];
    if (!o)
      throw new Error("Unrecognized array type.");
    const [i] = new Uint16Array(e, 2, 1), [l] = new Uint32Array(e, 4, 1);
    return new _Ce(l, i, o, e);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(e, t = 64, n = Float64Array, s) {
    if (isNaN(e) || e < 0)
      throw new Error(`Unpexpected numItems value: ${e}.`);
    this.numItems = +e, this.nodeSize = Math.min(Math.max(+t, 2), 65535), this.ArrayType = n, this.IndexArrayType = e < 65536 ? Uint16Array : Uint32Array;
    const o = Ge.indexOf(this.ArrayType), i = e * 2 * this.ArrayType.BYTES_PER_ELEMENT, l = e * this.IndexArrayType.BYTES_PER_ELEMENT, a = (8 - l % 8) % 8;
    if (o < 0)
      throw new Error(`Unexpected typed array class: ${n}.`);
    s && s instanceof ArrayBuffer ? (this.data = s, this.ids = new this.IndexArrayType(this.data, J, e), this.coords = new this.ArrayType(this.data, J + l + a, e * 2), this._pos = e * 2, this._finished = true) : (this.data = new ArrayBuffer(J + i + l + a), this.ids = new this.IndexArrayType(this.data, J, e), this.coords = new this.ArrayType(this.data, J + l + a, e * 2), this._pos = 0, this._finished = false, new Uint8Array(this.data, 0, 2).set([219, (de << 4) + o]), new Uint16Array(this.data, 2, 1)[0] = t, new Uint32Array(this.data, 4, 1)[0] = e);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(e, t) {
    const n = this._pos >> 1;
    return this.ids[n] = n, this.coords[this._pos++] = e, this.coords[this._pos++] = t, n;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    const e = this._pos >> 1;
    if (e !== this.numItems)
      throw new Error(`Added ${e} items when expected ${this.numItems}.`);
    return ge(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = true, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(e, t, n, s) {
    if (!this._finished)
      throw new Error("Data not yet indexed - call index.finish().");
    const { ids: o, coords: i, nodeSize: l } = this, a = [0, o.length - 1, 0], c = [];
    for (; a.length; ) {
      const d = a.pop() || 0, u = a.pop() || 0, f = a.pop() || 0;
      if (u - f <= l) {
        for (let g = f; g <= u; g++) {
          const v = i[2 * g], _ = i[2 * g + 1];
          v >= e && v <= n && _ >= t && _ <= s && c.push(o[g]);
        }
        continue;
      }
      const m = f + u >> 1, h = i[2 * m], p = i[2 * m + 1];
      h >= e && h <= n && p >= t && p <= s && c.push(o[m]), (d === 0 ? e <= h : t <= p) && (a.push(f), a.push(m - 1), a.push(1 - d)), (d === 0 ? n >= h : s >= p) && (a.push(m + 1), a.push(u), a.push(1 - d));
    }
    return c;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(e, t, n) {
    if (!this._finished)
      throw new Error("Data not yet indexed - call index.finish().");
    const { ids: s, coords: o, nodeSize: i } = this, l = [0, s.length - 1, 0], a = [], c = n * n;
    for (; l.length; ) {
      const d = l.pop() || 0, u = l.pop() || 0, f = l.pop() || 0;
      if (u - f <= i) {
        for (let g = f; g <= u; g++)
          Ve(o[2 * g], o[2 * g + 1], e, t) <= c && a.push(s[g]);
        continue;
      }
      const m = f + u >> 1, h = o[2 * m], p = o[2 * m + 1];
      Ve(h, p, e, t) <= c && a.push(s[m]), (d === 0 ? e - n <= h : t - n <= p) && (l.push(f), l.push(m - 1), l.push(1 - d)), (d === 0 ? e + n >= h : t + n >= p) && (l.push(m + 1), l.push(u), l.push(1 - d));
    }
    return a;
  }
};
function ge(r2, e, t, n, s, o) {
  if (s - n <= t)
    return;
  const i = n + s >> 1;
  Je(r2, e, i, n, s, o), ge(r2, e, t, n, i - 1, 1 - o), ge(r2, e, t, i + 1, s, 1 - o);
}
function Je(r2, e, t, n, s, o) {
  for (; s > n; ) {
    if (s - n > 600) {
      const c = s - n + 1, d = t - n + 1, u = Math.log(c), f = 0.5 * Math.exp(2 * u / 3), m = 0.5 * Math.sqrt(u * f * (c - f) / c) * (d - c / 2 < 0 ? -1 : 1), h = Math.max(n, Math.floor(t - d * f / c + m)), p = Math.min(s, Math.floor(t + (c - d) * f / c + m));
      Je(r2, e, t, h, p, o);
    }
    const i = e[2 * t + o];
    let l = n, a = s;
    for (X(r2, e, n, t), e[2 * s + o] > i && X(r2, e, n, s); l < a; ) {
      for (X(r2, e, l, a), l++, a--; e[2 * l + o] < i; )
        l++;
      for (; e[2 * a + o] > i; )
        a--;
    }
    e[2 * n + o] === i ? X(r2, e, n, a) : (a++, X(r2, e, a, s)), a <= t && (n = a + 1), t <= a && (s = a - 1);
  }
}
function X(r2, e, t, n) {
  fe(r2, t, n), fe(e, 2 * t, 2 * n), fe(e, 2 * t + 1, 2 * n + 1);
}
function fe(r2, e, t) {
  const n = r2[e];
  r2[e] = r2[t], r2[t] = n;
}
function Ve(r2, e, t, n) {
  const s = r2 - t, o = e - n;
  return s * s + o * o;
}
var fr = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: false,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: false,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (r2) => r2
  // props => ({sum: props.my_value})
};
var Fe = Math.fround || ((r2) => (e) => (r2[0] = +e, r2[0]))(new Float32Array(1));
var N = 2;
var x = 3;
var he = 4;
var L = 5;
var Xe = 6;
var Qe = class {
  constructor(e) {
    this.options = Object.assign(Object.create(fr), e), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(e) {
    const { log: t, minZoom: n, maxZoom: s } = this.options;
    t && console.time("total time");
    const o = `prepare ${e.length} points`;
    t && console.time(o), this.points = e;
    const i = [];
    for (let a = 0; a < e.length; a++) {
      const c = e[a];
      if (!c.geometry)
        continue;
      const [d, u] = c.geometry.coordinates, f = Fe(se(d)), m = Fe(oe(u));
      i.push(
        f,
        m,
        // projected point coordinates
        1 / 0,
        // the last zoom the point was processed at
        a,
        // index of the source feature in the original input array
        -1,
        // parent cluster id
        1
        // number of points in a cluster
      ), this.options.reduce && i.push(0);
    }
    let l = this.trees[s + 1] = this._createTree(i);
    t && console.timeEnd(o);
    for (let a = s; a >= n; a--) {
      const c = +Date.now();
      l = this.trees[a] = this._createTree(this._cluster(l, a)), t && console.log("z%d: %d clusters in %dms", a, l.numItems, +Date.now() - c);
    }
    return t && console.timeEnd("total time"), this;
  }
  getClusters(e, t) {
    let n = ((e[0] + 180) % 360 + 360) % 360 - 180;
    const s = Math.max(-90, Math.min(90, e[1]));
    let o = e[2] === 180 ? 180 : ((e[2] + 180) % 360 + 360) % 360 - 180;
    const i = Math.max(-90, Math.min(90, e[3]));
    if (e[2] - e[0] >= 360)
      n = -180, o = 180;
    else if (n > o) {
      const u = this.getClusters([n, s, 180, i], t), f = this.getClusters([-180, s, o, i], t);
      return u.concat(f);
    }
    const l = this.trees[this._limitZoom(t)], a = l.range(se(n), oe(i), se(o), oe(s)), c = l.data, d = [];
    for (const u of a) {
      const f = this.stride * u;
      d.push(c[f + L] > 1 ? ze(c, f, this.clusterProps) : this.points[c[f + x]]);
    }
    return d;
  }
  getChildren(e) {
    const t = this._getOriginId(e), n = this._getOriginZoom(e), s = "No cluster with the specified id.", o = this.trees[n];
    if (!o)
      throw new Error(s);
    const i = o.data;
    if (t * this.stride >= i.length)
      throw new Error(s);
    const l = this.options.radius / (this.options.extent * Math.pow(2, n - 1)), a = i[t * this.stride], c = i[t * this.stride + 1], d = o.within(a, c, l), u = [];
    for (const f of d) {
      const m = f * this.stride;
      i[m + he] === e && u.push(i[m + L] > 1 ? ze(i, m, this.clusterProps) : this.points[i[m + x]]);
    }
    if (u.length === 0)
      throw new Error(s);
    return u;
  }
  getLeaves(e, t, n) {
    t = t || 10, n = n || 0;
    const s = [];
    return this._appendLeaves(s, e, t, n, 0), s;
  }
  getTile(e, t, n) {
    const s = this.trees[this._limitZoom(e)], o = Math.pow(2, e), { extent: i, radius: l } = this.options, a = l / i, c = (n - a) / o, d = (n + 1 + a) / o, u = {
      features: []
    };
    return this._addTileFeatures(
      s.range((t - a) / o, c, (t + 1 + a) / o, d),
      s.data,
      t,
      n,
      o,
      u
    ), t === 0 && this._addTileFeatures(
      s.range(1 - a / o, c, 1, d),
      s.data,
      o,
      n,
      o,
      u
    ), t === o - 1 && this._addTileFeatures(
      s.range(0, c, a / o, d),
      s.data,
      -1,
      n,
      o,
      u
    ), u.features.length ? u : null;
  }
  getClusterExpansionZoom(e) {
    let t = this._getOriginZoom(e) - 1;
    for (; t <= this.options.maxZoom; ) {
      const n = this.getChildren(e);
      if (t++, n.length !== 1)
        break;
      e = n[0].properties.cluster_id;
    }
    return t;
  }
  _appendLeaves(e, t, n, s, o) {
    const i = this.getChildren(t);
    for (const l of i) {
      const a = l.properties;
      if (a && a.cluster ? o + a.point_count <= s ? o += a.point_count : o = this._appendLeaves(e, a.cluster_id, n, s, o) : o < s ? o++ : e.push(l), e.length === n)
        break;
    }
    return o;
  }
  _createTree(e) {
    const t = new Ce(e.length / this.stride | 0, this.options.nodeSize, Float32Array);
    for (let n = 0; n < e.length; n += this.stride)
      t.add(e[n], e[n + 1]);
    return t.finish(), t.data = e, t;
  }
  _addTileFeatures(e, t, n, s, o, i) {
    for (const l of e) {
      const a = l * this.stride, c = t[a + L] > 1;
      let d, u, f;
      if (c)
        d = et(t, a, this.clusterProps), u = t[a], f = t[a + 1];
      else {
        const p = this.points[t[a + x]];
        d = p.properties;
        const [g, v] = p.geometry.coordinates;
        u = se(g), f = oe(v);
      }
      const m = {
        type: 1,
        geometry: [[
          Math.round(this.options.extent * (u * o - n)),
          Math.round(this.options.extent * (f * o - s))
        ]],
        tags: d
      };
      let h;
      c || this.options.generateId ? h = t[a + x] : h = this.points[t[a + x]].id, h !== void 0 && (m.id = h), i.features.push(m);
    }
  }
  _limitZoom(e) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+e), this.options.maxZoom + 1));
  }
  _cluster(e, t) {
    const { radius: n, extent: s, reduce: o, minPoints: i } = this.options, l = n / (s * Math.pow(2, t)), a = e.data, c = [], d = this.stride;
    for (let u = 0; u < a.length; u += d) {
      if (a[u + N] <= t)
        continue;
      a[u + N] = t;
      const f = a[u], m = a[u + 1], h = e.within(a[u], a[u + 1], l), p = a[u + L];
      let g = p;
      for (const v of h) {
        const _ = v * d;
        a[_ + N] > t && (g += a[_ + L]);
      }
      if (g > p && g >= i) {
        let v = f * p, _ = m * p, E, q = -1;
        const P = ((u / d | 0) << 5) + (t + 1) + this.points.length;
        for (const b of h) {
          const C = b * d;
          if (a[C + N] <= t)
            continue;
          a[C + N] = t;
          const T = a[C + L];
          v += a[C] * T, _ += a[C + 1] * T, a[C + he] = P, o && (E || (E = this._map(a, u, true), q = this.clusterProps.length, this.clusterProps.push(E)), o(E, this._map(a, C)));
        }
        a[u + he] = P, c.push(v / g, _ / g, 1 / 0, P, -1, g), o && c.push(q);
      } else {
        for (let v = 0; v < d; v++)
          c.push(a[u + v]);
        if (g > 1)
          for (const v of h) {
            const _ = v * d;
            if (!(a[_ + N] <= t)) {
              a[_ + N] = t;
              for (let E = 0; E < d; E++)
                c.push(a[_ + E]);
            }
          }
      }
    }
    return c;
  }
  // get index of the point from which the cluster originated
  _getOriginId(e) {
    return e - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(e) {
    return (e - this.points.length) % 32;
  }
  _map(e, t, n) {
    if (e[t + L] > 1) {
      const i = this.clusterProps[e[t + Xe]];
      return n ? Object.assign({}, i) : i;
    }
    const s = this.points[e[t + x]].properties, o = this.options.map(s);
    return n && o === s ? Object.assign({}, o) : o;
  }
};
function ze(r2, e, t) {
  return {
    type: "Feature",
    id: r2[e + x],
    properties: et(r2, e, t),
    geometry: {
      type: "Point",
      coordinates: [hr(r2[e]), mr(r2[e + 1])]
    }
  };
}
function et(r2, e, t) {
  const n = r2[e + L], s = n >= 1e4 ? `${Math.round(n / 1e3)}k` : n >= 1e3 ? `${Math.round(n / 100) / 10}k` : n, o = r2[e + Xe], i = o === -1 ? {} : Object.assign({}, t[o]);
  return Object.assign(i, {
    cluster: true,
    cluster_id: r2[e + x],
    point_count: n,
    point_count_abbreviated: s
  });
}
function se(r2) {
  return r2 / 360 + 0.5;
}
function oe(r2) {
  const e = Math.sin(r2 * Math.PI / 180), t = 0.5 - 0.25 * Math.log((1 + e) / (1 - e)) / Math.PI;
  return t < 0 ? 0 : t > 1 ? 1 : t;
}
function hr(r2) {
  return (r2 - 0.5) * 360;
}
function mr(r2) {
  const e = (180 - r2 * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(e)) / Math.PI - 90;
}
function Oe(r2, e) {
  var t = {};
  for (var n in r2)
    Object.prototype.hasOwnProperty.call(r2, n) && e.indexOf(n) < 0 && (t[n] = r2[n]);
  if (r2 != null && typeof Object.getOwnPropertySymbols == "function")
    for (var s = 0, n = Object.getOwnPropertySymbols(r2); s < n.length; s++)
      e.indexOf(n[s]) < 0 && Object.prototype.propertyIsEnumerable.call(r2, n[s]) && (t[n[s]] = r2[n[s]]);
  return t;
}
var w = class {
  static isAdvancedMarkerAvailable(e) {
    return google.maps.marker && e.getMapCapabilities().isAdvancedMarkersAvailable === true;
  }
  static isAdvancedMarker(e) {
    return google.maps.marker && e instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(e, t) {
    this.isAdvancedMarker(e) ? e.map = t : e.setMap(t);
  }
  static getPosition(e) {
    if (this.isAdvancedMarker(e)) {
      if (e.position) {
        if (e.position instanceof google.maps.LatLng)
          return e.position;
        if (Number.isFinite(e.position.lat) && Number.isFinite(e.position.lng))
          return new google.maps.LatLng(e.position.lat, e.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return e.getPosition();
  }
  static getVisible(e) {
    return this.isAdvancedMarker(e) ? true : e.getVisible();
  }
};
var ee = class {
  constructor({ markers: e, position: t }) {
    this.markers = [], e && (this.markers = e), t && (t instanceof google.maps.LatLng ? this._position = t : this._position = new google.maps.LatLng(t));
  }
  get bounds() {
    if (this.markers.length === 0 && !this._position)
      return;
    const e = new google.maps.LatLngBounds(this._position, this._position);
    for (const t of this.markers)
      e.extend(w.getPosition(t));
    return e;
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((e) => w.getVisible(e)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(e) {
    this.markers.push(e);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (w.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
};
function A(r2, e = "assertion failed") {
  if (r2 == null)
    throw Error(e);
}
var gr = (r2, e, t, n) => {
  const s = r2.getBounds();
  A(s);
  const o = tt(s, e, n);
  return t.filter((i) => o.contains(w.getPosition(i)));
};
var tt = (r2, e, t) => {
  const { northEast: n, southWest: s } = yr(r2, e), o = _r({ northEast: n, southWest: s }, t);
  return Er(o, e);
};
var vr = (r2, e, t) => {
  const n = tt(r2, e, t), s = n.getNorthEast(), o = n.getSouthWest();
  return [o.lng(), o.lat(), s.lng(), s.lat()];
};
var yr = (r2, e) => {
  const t = e.fromLatLngToDivPixel(r2.getNorthEast()), n = e.fromLatLngToDivPixel(r2.getSouthWest());
  return A(t), A(n), { northEast: t, southWest: n };
};
var _r = ({ northEast: r2, southWest: e }, t) => (r2.x += t, r2.y -= t, e.x -= t, e.y += t, { northEast: r2, southWest: e });
var Er = ({ northEast: r2, southWest: e }, t) => {
  const n = t.fromDivPixelToLatLng(e), s = t.fromDivPixelToLatLng(r2);
  return new google.maps.LatLngBounds(n, s);
};
var rt = class {
  constructor({ maxZoom: e = 16 }) {
    this.maxZoom = e;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop({ markers: e }) {
    return kr(e);
  }
};
var wr = class extends rt {
  constructor(e) {
    var { viewportPadding: t = 60 } = e, n = Oe(e, ["viewportPadding"]);
    super(n), this.viewportPadding = 60, this.viewportPadding = t;
  }
  calculate({ markers: e, map: t, mapCanvasProjection: n }) {
    const s = t.getZoom();
    return A(s), s >= this.maxZoom ? {
      clusters: this.noop({
        markers: e
      }),
      changed: false
    } : {
      clusters: this.cluster({
        markers: gr(t, n, e, this.viewportPadding),
        map: t,
        mapCanvasProjection: n
      })
    };
  }
};
var kr = (r2) => r2.map((t) => new ee({
  position: w.getPosition(t),
  markers: [t]
}));
var Cr = class extends rt {
  constructor(e) {
    var { maxZoom: t, radius: n = 60 } = e, s = Oe(e, ["maxZoom", "radius"]);
    super({ maxZoom: t }), this.markers = [], this.clusters = [], this.state = { zoom: -1 }, this.superCluster = new Qe(Object.assign({ maxZoom: this.maxZoom, radius: n }, s));
  }
  calculate(e) {
    let t = false, n = e.map.getZoom();
    A(n), n = Math.round(n);
    const s = { zoom: n };
    if (!ae(e.markers, this.markers)) {
      t = true, this.markers = [...e.markers];
      const o = this.markers.map((i) => {
        const l = w.getPosition(i);
        return {
          type: "Feature",
          geometry: { type: "Point", coordinates: [l.lng(), l.lat()] },
          properties: { marker: i }
        };
      });
      this.superCluster.load(o);
    }
    return t || (this.state.zoom <= this.maxZoom || s.zoom <= this.maxZoom) && (t = !ae(this.state, s)), this.state = s, e.markers.length === 0 ? (this.clusters = [], { clusters: this.clusters, changed: t }) : (t && (this.clusters = this.cluster(e)), { clusters: this.clusters, changed: t });
  }
  cluster({ map: e }) {
    const t = e.getZoom();
    return A(t), this.superCluster.getClusters([-180, -90, 180, 90], Math.round(t)).map((n) => this.transformCluster(n));
  }
  transformCluster({ geometry: { coordinates: [e, t] }, properties: n }) {
    if (n.cluster)
      return new ee({
        markers: this.superCluster.getLeaves(n.cluster_id, 1 / 0).map((o) => o.properties.marker),
        position: { lat: t, lng: e }
      });
    const s = n.marker;
    return new ee({
      markers: [s],
      position: w.getPosition(s)
    });
  }
};
var Or = class extends wr {
  constructor(e) {
    var { maxZoom: t, radius: n = 60, viewportPadding: s = 60 } = e, o = Oe(e, ["maxZoom", "radius", "viewportPadding"]);
    super({ maxZoom: t, viewportPadding: s }), this.markers = [], this.clusters = [], this.superCluster = new Qe(Object.assign({ maxZoom: this.maxZoom, radius: n }, o)), this.state = { zoom: -1, view: [0, 0, 0, 0] };
  }
  calculate(e) {
    const t = this.getViewportState(e);
    let n = !ae(this.state, t);
    if (!ae(e.markers, this.markers)) {
      n = true, this.markers = [...e.markers];
      const s = this.markers.map((o) => {
        const i = w.getPosition(o);
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: [i.lng(), i.lat()]
          },
          properties: { marker: o }
        };
      });
      this.superCluster.load(s);
    }
    return n && (this.clusters = this.cluster(e), this.state = t), { clusters: this.clusters, changed: n };
  }
  cluster(e) {
    const t = this.getViewportState(e);
    return this.superCluster.getClusters(t.view, t.zoom).map((n) => this.transformCluster(n));
  }
  transformCluster({ geometry: { coordinates: [e, t] }, properties: n }) {
    if (n.cluster)
      return new ee({
        markers: this.superCluster.getLeaves(n.cluster_id, 1 / 0).map((o) => o.properties.marker),
        position: { lat: t, lng: e }
      });
    const s = n.marker;
    return new ee({
      markers: [s],
      position: w.getPosition(s)
    });
  }
  getViewportState(e) {
    const t = e.map.getZoom(), n = e.map.getBounds();
    return A(t), A(n), {
      zoom: Math.round(t),
      view: vr(n, e.mapCanvasProjection, this.viewportPadding)
    };
  }
};
var Mr = class {
  constructor(e, t) {
    this.markers = { sum: e.length };
    const n = t.map((o) => o.count), s = n.reduce((o, i) => o + i, 0);
    this.clusters = {
      count: t.length,
      markers: {
        mean: s / t.length,
        sum: s,
        min: Math.min(...n),
        max: Math.max(...n)
      }
    };
  }
};
var Pr = class {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render({ count: e, position: t }, n, s) {
    const i = `<svg fill="${e > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff"}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">${e}</text>
</svg>`, l = `Cluster of ${e} markers`, a = Number(google.maps.Marker.MAX_ZINDEX) + e;
    if (w.isAdvancedMarkerAvailable(s)) {
      const u = new DOMParser().parseFromString(i, "image/svg+xml").documentElement;
      u.setAttribute("transform", "translate(0 25)");
      const f = {
        map: s,
        position: t,
        zIndex: a,
        title: l,
        content: u
      };
      return new google.maps.marker.AdvancedMarkerElement(f);
    }
    const c = {
      position: t,
      zIndex: a,
      title: l,
      icon: {
        url: `data:image/svg+xml;base64,${btoa(i)}`,
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(c);
  }
};
function br(r2, e) {
  for (let t in e.prototype)
    r2.prototype[t] = e.prototype[t];
}
var Me = class _Me {
  constructor() {
    br(_Me, google.maps.OverlayView);
  }
};
var I;
(function(r2) {
  r2.CLUSTERING_BEGIN = "clusteringbegin", r2.CLUSTERING_END = "clusteringend", r2.CLUSTER_CLICK = "click", r2.GMP_CLICK = "gmp-click";
})(I || (I = {}));
var Sr = (r2, e, t) => {
  e.bounds && t.fitBounds(e.bounds);
};
var Ar = class extends Me {
  constructor({ map: e, markers: t = [], algorithmOptions: n = {}, algorithm: s = new Cr(n), renderer: o = new Pr(), onClusterClick: i = Sr }) {
    super(), this.map = null, this.idleListener = null, this.markers = [...t], this.clusters = [], this.algorithm = s, this.renderer = o, this.onClusterClick = i, e && this.setMap(e);
  }
  addMarker(e, t) {
    this.markers.includes(e) || (this.markers.push(e), t || this.render());
  }
  addMarkers(e, t) {
    e.forEach((n) => {
      this.addMarker(n, true);
    }), t || this.render();
  }
  removeMarker(e, t) {
    const n = this.markers.indexOf(e);
    return n === -1 ? false : (w.setMap(e, null), this.markers.splice(n, 1), t || this.render(), true);
  }
  removeMarkers(e, t) {
    let n = false;
    return e.forEach((s) => {
      n = this.removeMarker(s, true) || n;
    }), n && !t && this.render(), n;
  }
  clearMarkers(e) {
    this.markers.length = 0, e || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    const e = this.getMap();
    if (e instanceof google.maps.Map && e.getProjection()) {
      google.maps.event.trigger(this, I.CLUSTERING_BEGIN, this);
      const { clusters: t, changed: n } = this.algorithm.calculate({
        markers: this.markers,
        map: e,
        mapCanvasProjection: this.getProjection()
      });
      if (n || n == null) {
        const s = /* @__PURE__ */ new Set();
        for (const i of t)
          i.markers.length == 1 && s.add(i.markers[0]);
        const o = [];
        for (const i of this.clusters)
          i.marker != null && (i.markers.length == 1 ? s.has(i.marker) || w.setMap(i.marker, null) : o.push(i.marker));
        this.clusters = t, this.renderClusters(), requestAnimationFrame(() => o.forEach((i) => w.setMap(i, null)));
      }
      google.maps.event.trigger(this, I.CLUSTERING_END, this);
    }
  }
  onAdd() {
    const e = this.getMap();
    A(e), this.idleListener = e.addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    this.idleListener && google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((e) => w.setMap(e, null)), this.clusters.forEach((e) => e.delete()), this.clusters = [];
  }
  renderClusters() {
    const e = new Mr(this.markers, this.clusters), t = this.getMap();
    this.clusters.forEach((n) => {
      if (n.markers.length === 1)
        n.marker = n.markers[0];
      else if (n.marker = this.renderer.render(n, e, t), n.markers.forEach((s) => w.setMap(s, null)), this.onClusterClick) {
        const s = w.isAdvancedMarker(n.marker) ? I.GMP_CLICK : I.CLUSTER_CLICK;
        n.marker.addListener(
          s,
          /* istanbul ignore next */
          (o) => {
            google.maps.event.trigger(this, I.CLUSTER_CLICK, n), this.onClusterClick(o, n, t);
          }
        );
      }
      w.setMap(n.marker, t);
    });
  }
};
var We = Object.values(I);
var Fr = defineComponent({
  name: "MarkerCluster",
  props: {
    options: {
      type: Object,
      default: () => ({})
    }
  },
  emits: We,
  setup(r2, { emit: e, expose: t, slots: n }) {
    const s = ref(), o = inject(B, ref()), i = inject(D, ref());
    return provide(we, s), watch(
      o,
      () => {
        o.value && (s.value = markRaw(
          new Ar({
            map: o.value,
            // Better perf than the default `SuperClusterAlgorithm`. See:
            // https://github.com/googlemaps/js-markerclusterer/pull/640
            algorithm: new Or(r2.options.algorithmOptions ?? {}),
            ...r2.options
          })
        ), We.forEach((l) => {
          var a;
          (a = s.value) == null || a.addListener(l, (c) => e(l, c));
        }));
      },
      {
        immediate: true
      }
    ), onBeforeUnmount(() => {
      var l;
      s.value && ((l = i.value) == null || l.event.clearInstanceListeners(s.value), s.value.clearMarkers(), s.value.setMap(null));
    }), t({ markerCluster: s }), () => {
      var l;
      return (l = n.default) == null ? void 0 : l.call(n);
    };
  }
});
var qr = defineComponent({
  inheritAttrs: false,
  props: {
    options: {
      type: Object,
      required: true
    }
  },
  setup(r2, { slots: e, emit: t, expose: n }) {
    const s = ref(), o = computed(() => {
      var a;
      return (a = e.default) == null ? void 0 : a.call(e).some((c) => c.type !== Comment);
    }), i = computed(() => ({
      ...r2.options,
      element: s.value
    })), l = H(le, [], i, t);
    return n({
      customMarker: l
    }), { customMarkerRef: s, customMarker: l, hasSlotContent: o };
  }
});
var Tr = {
  key: 0,
  class: "custom-marker-wrapper"
};
function Lr(r2, e, t, n, s, o) {
  return r2.hasSlotContent ? (openBlock(), createElementBlock("div", Tr, [
    createBaseVNode("div", mergeProps({
      ref: "customMarkerRef",
      style: { cursor: r2.$attrs.onClick ? "pointer" : void 0 }
    }, r2.$attrs), [
      renderSlot(r2.$slots, "default", {}, void 0, true)
    ], 16)
  ])) : createCommentVNode("", true);
}
var zr = te(qr, [["render", Lr], ["__scopeId", "data-v-2d2d343a"]]);
var Wr = defineComponent({
  name: "HeatmapLayer",
  props: {
    options: {
      type: Object,
      default: () => ({})
    }
  },
  setup(r2) {
    const e = ref(), t = inject(B, ref()), n = inject(D, ref());
    return watch(
      [t, () => r2.options],
      ([s, o], [i, l]) => {
        const a = !Q(o, l) || t.value !== i;
        if (t.value && n.value && a) {
          let c;
          if (o.data && !(o.data instanceof n.value.MVCArray)) {
            const d = n.value.LatLng, u = o.data.map((f) => f instanceof d || "location" in f && (f.location instanceof d || f.location === null) ? f : "location" in f ? { ...f, location: new d(f.location) } : new d(f));
            c = {
              ...o,
              data: u
            };
          } else
            c = o;
          e.value ? e.value.setOptions(c) : e.value = markRaw(
            new n.value.visualization.HeatmapLayer({
              ...c,
              map: t.value
            })
          );
        }
      },
      { immediate: true }
    ), onBeforeUnmount(() => {
      e.value && e.value.setMap(null);
    }), { heatmapLayer: e };
  },
  render: () => null
});
export {
  Nr as AdvancedMarker,
  Ur as Circle,
  Gr as CustomControl,
  zr as CustomMarker,
  jr as GoogleMap,
  Wr as HeatmapLayer,
  Vr as InfoWindow,
  $r as Marker,
  Fr as MarkerCluster,
  Dr as Polygon,
  Br as Polyline,
  Zr as Rectangle,
  D as apiSymbol,
  B as mapSymbol,
  Ke as mapTilesLoadedSymbol
};
//# sourceMappingURL=vue3-google-map.js.map
